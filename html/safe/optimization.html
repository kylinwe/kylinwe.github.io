<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>前端性能优化</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <link rel="stylesheet" href="../../css/normalize.css">
        <link rel="stylesheet" href="../../css/font-awesome.css">
        <link rel="stylesheet" href="../../css/bootstrap.min.css">
        <link rel="stylesheet" href="../../css/templatemo-style.css">
        <link rel="stylesheet" type="text/css" href="../../sass/main.css">
        <script src="../../lib/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
    
        <div class="responsive-header visible-xs visible-sm">
            <div class="container">
                <div class="row">
                    <div class="col-md-12">
                        <div class="top-section">
                            <div class="profile-image">
                                <img src="../../img/author.jpg" alt="Kylin">
                            </div>
                            <h3 class="profile-title">卡戎</h3>
                            <p class="profile-description">Kylin</p>
                        </div>
                    </div>
                </div>
                <a href="#" class="toggle-menu"><i class="fa fa-bars"></i></a>
                <div class="main-navigation responsive-menu">
                    <ul class="navigation">
                        <li><a href="../base.html"><i class="fa fa-pencil"></i>HTML</a></li>
                        <li><a href="#css"><i class="fa fa-pencil"></i>CSS</a></li>
                        <li><a href="#javascript"><i class="fa fa-pencil"></i>JavaScript</a></li>
                        <li><a href="#http"><i class="fa fa-pencil"></i>HTTP协议</a></li>
                    </ul>
                </div>
            </div>
        </div>
		
        <!-- SIDEBAR -->
        <div class="sidebar-menu hidden-xs hidden-sm">
            <div class="top-section">
                <div class="profile-image">
                    <img src="../../img/author.jpg" alt="Kylin">
                </div>
                <h3 class="profile-title">卡戎</h3>
                <p class="profile-description">Kylin</p>
            </div> <!-- top-section -->
            <div class="main-navigation">
                <ul class="navigation">
                    <li><a href="../base.html"><i class="fa fa-pencil"></i>HTML</a></li>
                    <li><a href="#css"><i class="fa fa-pencil"></i>CSS</a></li>
                    <li><a href="#javascript"><i class="fa fa-pencil"></i>JavaScript</a></li>
                    <li><a href="#http"><i class="fa fa-pencil"></i>HTTP协议</a></li>
                </ul>
            </div> <!-- .main-navigation -->
        </div> <!-- .sidebar-menu -->
    	
        <div class="banner-bg" id="top">
            <div class="banner-overlay"></div>
            <div class="welcome-text">
                <p>
                   1、为什么要进行前端优化？
                   <br />
（1）事实上，只有10%-20%的最终用户响应时间是花在从web服务器获取HTML文档并传送到浏览器的，至少80%的最终用户响应时间是花在了页面中的组件上（图片、脚本、样式表、Flash等）
（2）在请求脚本时不会发生并行请求，这是因为在很多情况下，浏览器在下载脚本时会阻塞额外的http请求
<br />
2、HTTP?
<br />
（1）http是浏览器和服务器通过Internet进行相互通信的协议，http1.1是今天比较常见的版本
<br />
（2）http是一种客户端/服务器协议，由请求和响应构成。浏览器向一个特定的URL发送http请求，URL对应的宿主服务器发回http响应。和很多Internet服务一样，该协议使用简单的纯文本格式。请求的类型有GET、POST等类型
<br />
（3）GET请求包含一个URL，然后是头。http响应包含状态码，头和响应体
<br />
（4）如果浏览器和服务器都支持的话，可以使用压缩来减小响应的大小，浏览器可以使用Acceot-Encoding头来声明它支持压缩，服务器使用Content-Encoding头确认响应已被压缩
<br />

3、前端优化规则？
<br />
（1）规则1：减少HTTP请求
<br />
改善响应时间的最简单途径就是减少组件(图片，脚本，样式表、Flash等）的数量，并由此减少http请求的数量
a、CSS Sprites：将多个图片合并到一个单独的图片中，再结合css的background-position属性一起使用，通过合并图片减少http请求（合并后的图片会比分离的图片的总和要小，因为它降低了图片自身的开销（颜色表，格式信息等））
<br />
适用场景：若需要在页面中为背景，按钮，导航栏，链接等提供大量图片，可使用CSS Sprites
b、合并脚本和样式表：若将css代码和javascript代码分别放在多个文件中，每个文件都会导致一个额外的http请求，将这些文件合并到一个文件中，可以减少http请求的数量并缩短最终用户时间
注：若不同页面需要不同的脚本，可能脚本合并的组合数会比较多
<br />
（2）规则2：使用内容发布网络
<br />
通常来说，Web客户端离当前Web服务器越近，响应时间会更快
a、内容发布网络：内容发布网络是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容
<br />
b、一些大型公司都拥有他们自己的CDN，但使用一个CDN服务提供商更为有效
<br />
优点：对于地理上分散的用户人群来说，CDN能轻易地得到响应速度上的提高
          除了缩短响应时间之外，CDN还提供备份，扩展存储功能和进行缓存等服务
缺点：CDN服务开销可能比较大，且CDN服务提供商在其所有客户之间共享其Web服务组，可能会受到其它网站流量的影响,无法直接控制组件服务器所带来的特殊麻烦，如修改HTTP响应头必须通过服务器提供商来完成
<br />
（3）规则3：添加Expires头
<br />
a、主要通过配置组件，使用一个长久的Expires头，使这些组件能够被缓存，使在后续的页面浏览中避免不必要的http请求（浏览器可以直接从硬盘上读取组件而无需生成任何http流量）,web服务器使用Expires头来告诉web客户端它可以使用一个组件的当前副本，直到指定的时间为止
<br />
b、长久的Expires头最常用于图片，但应该将其应用在所有组件上，包括脚本、样式表和Flash等不经常变化的组件，但添加长久的Expires会带来额外的开发成本
<br />
c、浏览器（和代理）通过使用缓存来减少http请求的数量，并减小http响应的大小，从而使页面加载得更快，Expires在http响应中发送，web服务器通过使用Expires头来告诉Web客户端它可以使用一个组件的当前副本
<br />
d、Expires头的限制：Expires头使用一个特定的时间，它要求服务器和客户端的时钟严格同步，另外，如果到了过期时间，需要在服务器配置中提供一个新的日期
<br />
e、Cache-Control头：http1.1引入的，主要用来克服Expires的限制
主要使用max-age指令指定组件被缓存多久
<br />
注：可以同时指定Expires和Cache-Control两个响应头，因为有些浏览器不支持http1.1
<br />
f、修订文件名：
<br />
为了确保用户能够获取组件的最新版本，需要在所有HTML页面中修改组件的文件名
g、一个具有长久的Expires头的组件将会被缓存，在后续请求时浏览器直接从磁盘上读取它，避免了一个http请求.如果一个组件没有长久的Expires头，它仍然会存储在浏览器的缓存中，在后续请求中，浏览器会检查缓存并发现组件以及过期。为了提高笑脸包，浏览西会向原始服务器发送一个条件GET请求，如果组件没有改变，原始服务器可以免于发送整个组件，而是发送一个很小的头，告诉浏览器可以使用其缓存的组件
<br />
（4）规则4：压缩组件（使用gzip编码压缩http响应包）
<br />
a、主要通过http响应的大小来减少响应时间，从http1.1开始，Web客户端可以通过http请求中的Accept-Encoding来标识对压缩的支持.如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来压缩响应，Web服务器通过响应中的Content-Encoding头来通知Web客户端
<br />
b、压缩什么：一般压缩HTML文档、样式表和脚本
<br />
c、压缩的成本：服务器端会花费额外的CPU周期来完成压缩，客户端要对压缩文件进行解压缩
<br />
（5）规则5：将样式表放在顶部
<br />
a、将样式表放在底部，可能会延迟页面的加载，会出现“白屏”和“无样式闪烁”，将样式表放在顶部，可以使页面逐步呈现，避免页面出现”白屏“和“无样式闪烁”
<br />
b、白屏：浏览器延迟内容呈现，直到所有的样式表都下载完毕后才开始开始显示内容，即页面完全空白，直到页面所有内容同时涌上屏幕
<br />无样式闪烁：样式表被正确地下载及解析，已经呈现的页面和图片要用新的样式重绘
c、link和@import：<br />
注：使用@import规则可能会导致白屏现象，即使是放在<head>中,一般组件都是按照它们在页面中出现的顺序下载的，而使用@import会带来下载时的无序性
<br />
（6）规则6：将脚本放在底部<br />
a、将脚本放在底部，既可以使页面逐步呈现，也可以提高下载的并行度<br />
b、将样式表放在<head>中，可以首先下载它们而不会阻止页面呈现，使用脚本时，对于所有位于脚本以下的内容，逐步呈现都被阻塞了。将脚本放在页面越靠下的地方，意味着越多的内容能够逐步地呈现<br />
c、http1.1建议浏览器从每个主机名并行地下载两个组件。然而，在下载脚本时并行下载其实是被禁用的，即使是用了不同的主机名，浏览器也不会启动其他的下载<br />
d、脚本对web页面的影响：脚本会阻塞其后面内容的呈现，脚本会阻塞其后面组件的下载（脚本会阻塞并行下载）<br />
（7）规则7：避免CSS表达式<br />
a、CSS表达式不只在页面呈现和大小改变时求值，当页面滚动，甚至连用户鼠标的页面移动时都要求值<br />
（8）规则8：使用外部的JavaScript和CSS<br />
a、在某种程度上，内联会快一些，尽管总下载量时是相同的，但外部示例需要承担多个http请求带来的开销。但是现实中还是使用外部文件会产生比较快的页面，因为javascript和css文件有可能被浏览器缓存起来<br />
b、使用外部文件可以提高组件的重用率<br />
（9）规则9：减少DNS查找<br />
a、Internet是通过IP地址来查找服务器的，由于IP地址很难记忆，通常使用包含主机名的URL来代替它，但当浏览器发送其请求时，IP地址仍然是必需的，这就是Domain Name System(DNS)所处的角色。DNS将主机名映射到IP地址上，在输入一个URL时，连接到浏览器的DNS解析器会返回服务器的IP地址<br />
b、DNS也是开销，在DNS查找完成之前，浏览器不能从主机名那里下载到任何东西，响应时间依赖于DNS解析器（通常由你的ISP提供）<br />
c、DNS缓存：DNS查找可以被缓存起来以提高性能，在用户请求了一个主机名后，DNS信息会留在操作系统的DNS缓存中，之后对于该主机名的请求将无需进行过多的DNS查找<br />
d、通过使用keep-Alive和较少的域名来减少DNS查找<br />
（10）规则10：精简Javascript<br />
a、精简是从代码中移除不必要的字符以减小其大小进而改善加载时间，在代码被精简后，所有的注释以及不必要的空白字符都将被移除<br />
b、内联的javascript也应该被精简<br />
c、精简CSS能够带来的节省通常要小于精简javascript，因为css中的注释和空白比javascript中的少，最大的潜在节省来自于优化CSS——合并相同的类，移除不适用的类等<br />
（11）规则11：避免重定向<br />
a、重定向就是，在网页上设置一个约束条件，条件满足，就自动转入到其它网页、网址<br />
b、重定向用于将用户从一个url重新路由到另一个url，重定向有很多种——301和302是最常用的两种，重定向会使你的页面变慢<br />
c、当web服务器向浏览器返回一个重定向时，响应中就会返回一个范围在3xx的状态码，这表示用户代理必需执行进一步操作才能完成请求<br />
注：304并不是真的重定向，它用来响应条件GET请求，避免下载已经存在于浏览器缓存中的数据<br />
d、重定向是如何损伤性能的：重定向会延迟整个HTML文档的传输，在HTML文档到达之前，页面中不会呈现出任何东西，也没有任何组件会被下载<br />
（12）规则12：移除重复脚本<br />
a、重复脚本损伤性能的方式有两种——不必要的HTTP请求和执行javascript所浪费的时间<br />
b、在页面中多次包含相同的脚本会使页面变慢.在IE中，如果脚本没有被缓存，或在重新加载页面时，会产生额外的http请求.在火狐和IE中，脚本会被多次求值<br />
（13）规则13：配置ETag<br />
a、ETag（实体标签）是web服务器和浏览器用于确认缓存组件的一种机制<br />
b、浏览器下载组件时，会将ta它们存储到缓存中，在后续的页面查看中，如果缓存的组件是“新鲜”的，浏览器就会从磁盘上读取它，避免产生http请求，如果缓存的组件过期了（或者用户明确地重新加载了页面），浏览器在重用它之前必须首先检查它是否仍然有效，这称为一个条件get请求，如果浏览器缓存中的组件是有效的（即它能够和原始服务器上的组件相匹配），原始服务器不会返回整个组件，而是返回一个304的状态码<br />
c、服务器在检测缓存的组件是否和原始服务器上的组件匹配时有两种方式：比较最新修改日期，比较实体标签（ETag是唯一标识了一个组件的一个特定版本的字符串）<br />
d、ETag带来的问题，当浏览器向一台服务器获取了原始组件，又向另一台不同的服务器发起条件get请求时，ETag是不会匹配的<br />
e、即使组件具有长久的Expires头，一旦用户单击了Reload或Refresh按钮。依然会产生条件get请求
（14）规则14：使Ajax可缓存<br />
<br />
浏览器缓存？<br />
浏览器（和代理）使用缓存来减少HTTP请求的数量，并减小HTTP响应的大小。如果某个文件不需要经常变动的，则最好使用缓存<br />
（1）添加Expires头<br />
a、Web服务器使用Expires头来告诉Web客户端它可以使用一个组件的当前副本，直到指定的时间为止，它在HTTP响应中发送<br />

b、Expires头的限制：Expires头使用了一个特定的时间，它要求服务器和客户端的时钟严格同步，另外，过期时间需要经常检查，并且未来这一天到来了，还需要在服务器配置中提供一个新的日期<br />
c、一个具有长久Expires头的组件将会被缓存，在后续请求时浏览器直接从磁盘上读取它，避免了一个HTTP请求。如果一个组件没有长久的Expires头，它仍然会存储在浏览器缓存中，在后续的请求中，浏览器会检查缓存并发现组件以及过期，为了提高效率，浏览器会向原始服务器发送一个条件GET请求，如果组件没有改变，原始服务器可以免于发送整个组件，而是发送一个很小的头，告诉浏览器可以使用其缓存的组件<br />
（2）Max-Age：<br />
a、Cache-Control使用max-age指令指定组件被缓存多久，它以秒为单位定义了一个更新窗。如果从组件被请求开始过去的秒数少于max-age，浏览器就会使用缓存的版本，这就避免了额外的HTTP请求<br />

Cache-Control的限制：对于不支持HTTP1.1的浏览器，无法使用Cache-Control，但可以提供Expires头。如果两者同时出现，HTTP规范规定max-age将重写Expires头<br />
（3）修订文件名：<br />
如果我们将组件配置为可以由浏览器代理缓存，当这些组件改变时，需采取一定方法通知客户端需要更新相应组件。最有效的解决方案就是修改其所有链接，这样，全部的请求将从原始服务器下载更新的内容<br />
a、可以将版本号嵌在组件的文件名中<br />
b、若使用PHP等动态语言生成HTML页，可以为所有组件文件名使用变量<br />
                </p>
            </div>
        </div>
        <script src="../../lib/vendor/jquery-1.10.2.min.js"></script>
        <script src="../../lib/min/plugins.min.js"></script>
        <script src="../../lib/min/main.min.js"></script>

    </body>
</html>